## Protocol Objects

### Identity
- Public key as identifier
- Proof-of-personhood inputs
- Reputation ledger (non-transferable)

### Proposal
- Unique ID
- Linked artifacts (IPFS hashes)
- Budget and assets
- Milestone schedule

### Vote
- Signed by identity key
- Time-bounded
- Verifiable inclusion

### Transaction
- Asset-agnostic
- Deterministic validation
- Auditable flows

## Consensus (Initial)
- Deterministic validation per node
- Gossip-based propagation
- Eventual consistency

## Oracles
- Multi-source verification
- Human reports with stake
- Sensor/satellite inputs (optional)

## Upgrades
- Backwards-compatible by default
- Governed feature flags
- Forks are first-class


## Execution

### Execution Model (v2 – Metrics, Escrow, Reputation)

Execution is **permissionless**, **risk-based**, and **fully auditable**. No trust, authority, or institutional role is required.

---

## 1. Core Principles

- Voting authorizes **project activation**, not execution control
- Execution always risks reputation
- Funds are released only through verified milestones
- Metrics must converge across independent sources

---

## 2. Actor States

```go
type Actor struct {
    ID         PublicKey
    Reputation float64
    Active     bool // false = locked reputation
    Status     ActorStatus
}
```

- Initial reputation: `10 (LOCKED)`
- Reputation becomes **ACTIVE** only when the actor executes, audits, or leads

---

## 3. Project Types

The system is **domain-agnostic**. Projects are not limited to physical infrastructure or geographic execution.

```go
type ProjectType int

const (
    Funded ProjectType = iota
    Volunteer
)
```

### Supported Project Domains

Projects MAY be:

- Physical (infrastructure, environment, security, logistics)
- Digital (software, protocols, research, datasets)
- Hybrid (physical execution with digital coordination)
- Creative or experimental (ideas, prototypes, simulations)

The execution layer does not privilege any domain. Only **metrics and verification** matter.

---


## 4. Project Definition

```go
type Project struct {
    ID            Hash
    Type          ProjectType
    ScopeLevel    int
    RiskFactor    float64
    Metrics       []Metric
    Milestones    []Milestone
    EscrowBalance Amount
}
```

---

## 5. Metrics System

Each project MUST define multiple metrics.

```go
type Metric struct {
    ID        string
    Source    MetricSource
    Weight    float64
}
```

### Metric Sources

```go
type MetricSource int

const (
    Internal MetricSource = iota
    Oracle
    Audit
)
```

Project success is determined by **weighted convergence**, not a single score.

---

## 6. Execution Lifecycle

1. Community votes → project ACTIVATED
2. Funds (if any) move to **project escrow**
3. Executor commits `RiskFactor` reputation
4. Milestones executed sequentially
5. Metrics continuously collected
6. Auditors validate convergence
7. Milestone success releases funds

---

## 7. Escrow & Payments

```text
treasury → project escrow → milestone release → executor
```

- No upfront full payments
- Failed milestones:
  - funds frozen or returned
  - reputation penalties applied

---

## 8. Reputation Mechanics

### Success

```text
gain = risk * efficiencyMultiplier
```

- efficiencyMultiplier ∈ [1.1 – 2.0]

### Failure

- Minor: `loss = risk * 1.2`
- Severe/fraud: `loss = risk * 2.0`

If reputation < 0 → **automatic suspension**

---

## 9. Volunteer Projects

- No escrow
- Same metrics and audits
- Reputation gain/loss identical

Volunteer work is **first-class execution**, not secondary participation.

---

## 10. Reputation Decay

```text
decay = 1% per week of inactivity (ACTIVE only)
```

Locked reputation does not decay.

---

## 11. System Guarantees

- No actor is irreplaceable
- Inefficiency is expensive
- Execution defines legitimacy
- Coordination outperforms coercion

---

This execution layer enables real-world action without borders, authority, or trust, while remaining compatible with any existing state or organization.
